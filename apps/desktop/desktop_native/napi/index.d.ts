/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare namespace autofill {
  export class AutofillIpcServer {
    /**
     * Create and start the IPC server without blocking.
     *
     * @param name The endpoint name to listen on. This name uniquely identifies the IPC
     * connection and must be the same for both the server and client. @param callback
     * This function will be called whenever a message is received from a client.
     */
    static listen(name: string, registrationCallback: (error: null | Error, clientId: number, sequenceNumber: number, message: PasskeyRegistrationRequest) => void, assertionCallback: (error: null | Error, clientId: number, sequenceNumber: number, message: PasskeyAssertionRequest) => void, assertionWithoutUserInterfaceCallback: (error: null | Error, clientId: number, sequenceNumber: number, message: PasskeyAssertionWithoutUserInterfaceRequest) => void, nativeStatusCallback: (error: null | Error, clientId: number, sequenceNumber: number, message: NativeStatus) => void): Promise<AutofillIpcServer>
    /** Return the path to the IPC server. */
    getPath(): string
    /** Stop the IPC server. */
    stop(): void
    completeRegistration(clientId: number, sequenceNumber: number, response: PasskeyRegistrationResponse): number
    completeAssertion(clientId: number, sequenceNumber: number, response: PasskeyAssertionResponse): number
    completeError(clientId: number, sequenceNumber: number, error: string): number
  }
  export interface NativeStatus {
    key: string
    value: string
  }
  export interface PasskeyAssertionRequest {
    rpId: string
    clientDataHash: Array<number>
    userVerification: UserVerification
    allowedCredentials: Array<Array<number>>
    windowXy: Position
  }
  export interface PasskeyAssertionResponse {
    rpId: string
    userHandle: Array<number>
    signature: Array<number>
    clientDataHash: Array<number>
    authenticatorData: Array<number>
    credentialId: Array<number>
  }
  export interface PasskeyAssertionWithoutUserInterfaceRequest {
    rpId: string
    credentialId: Array<number>
    userName: string
    userHandle: Array<number>
    recordIdentifier?: string
    clientDataHash: Array<number>
    userVerification: UserVerification
    windowXy: Position
  }
  export interface PasskeyRegistrationRequest {
    rpId: string
    userName: string
    userHandle: Array<number>
    clientDataHash: Array<number>
    userVerification: UserVerification
    supportedAlgorithms: Array<number>
    windowXy: Position
    excludedCredentials: Array<Array<number>>
  }
  export interface PasskeyRegistrationResponse {
    rpId: string
    clientDataHash: Array<number>
    credentialId: Array<number>
    attestationObject: Array<number>
  }
  export interface Position {
    x: number
    y: number
  }
  export function runCommand(value: string): Promise<string>
  export const enum UserVerification {
    Preferred = 'preferred',
    Required = 'required',
    Discouraged = 'discouraged'
  }
}

export declare namespace autostart {
  export function setAutostart(autostart: boolean, params: Array<string>): Promise<void>
}

export declare namespace autotype {
  export function getForegroundWindowTitle(): string
  export function typeInput(input: Array<number>, keyboardShortcut: Array<string>): void
}

export declare namespace biometrics {
  export function available(): Promise<boolean>
  /**
   * Derives key material from biometric data. Returns a string encoded with a
   * base64 encoded key and the base64 encoded challenge used to create it
   * separated by a `|` character.
   *
   * If the iv is provided, it will be used as the challenge. Otherwise a random challenge will
   * be generated.
   *
   * `format!("<key_base64>|<iv_base64>")`
   */
  export function deriveKeyMaterial(iv?: string | undefined | null): Promise<OsDerivedKey>
  /**
   * Retrieves the biometric secret for the given service and account.
   * Throws Error with message [`passwords::PASSWORD_NOT_FOUND`] if the secret does not exist.
   */
  export function getBiometricSecret(service: string, account: string, keyMaterial?: KeyMaterial | undefined | null): Promise<string>
  export interface KeyMaterial {
    osKeyPartB64: string
    clientKeyPartB64?: string
  }
  export interface OsDerivedKey {
    keyB64: string
    ivB64: string
  }
  export function prompt(hwnd: Buffer, message: string): Promise<boolean>
  export function setBiometricSecret(service: string, account: string, secret: string, keyMaterial: KeyMaterial | undefined | null, ivB64: string): Promise<string>
}

export declare namespace biometrics_v2 {
  export class BiometricLockSystem {

  }
  export function authenticate(biometricLockSystem: BiometricLockSystem, hwnd: Buffer, message: string): Promise<boolean>
  export function authenticateAvailable(biometricLockSystem: BiometricLockSystem): Promise<boolean>
  export function enrollPersistent(biometricLockSystem: BiometricLockSystem, userId: string, key: Buffer): Promise<void>
  export function hasPersistent(biometricLockSystem: BiometricLockSystem, userId: string): Promise<boolean>
  export function initBiometricSystem(): BiometricLockSystem
  export function provideKey(biometricLockSystem: BiometricLockSystem, userId: string, key: Buffer): Promise<void>
  export function unenroll(biometricLockSystem: BiometricLockSystem, userId: string): Promise<void>
  export function unlock(biometricLockSystem: BiometricLockSystem, userId: string, hwnd: Buffer): Promise<Buffer>
  export function unlockAvailable(biometricLockSystem: BiometricLockSystem, userId: string): Promise<boolean>
}

export declare namespace chromium_importer {
  export function getAvailableProfiles(browser: string): Array<ProfileInfo>
  /** Returns OS aware metadata describing supported Chromium based importers as a JSON string. */
  export function getMetadata(): Record<string, NativeImporterMetadata>
  export function importLogins(browser: string, profileId: string): Promise<Array<LoginImportResult>>
  export interface Login {
    url: string
    username: string
    password: string
    note: string
  }
  export interface LoginImportFailure {
    url: string
    username: string
    error: string
  }
  export interface LoginImportResult {
    login?: Login
    failure?: LoginImportFailure
  }
  export interface NativeImporterMetadata {
    id: string
    loaders: Array<string>
    instructions: string
  }
  export interface ProfileInfo {
    id: string
    name: string
  }
}

export declare namespace clipboards {
  export function read(): Promise<string>
  export function write(text: string, password: boolean): Promise<void>
}

export declare namespace ipc {
  export class NativeIpcServer {
    /**
     * Create and start the IPC server without blocking.
     *
     * @param name The endpoint name to listen on. This name uniquely identifies the IPC
     * connection and must be the same for both the server and client. @param callback
     * This function will be called whenever a message is received from a client.
     */
    static listen(name: string, callback: (error: null | Error, message: IpcMessage) => void): Promise<NativeIpcServer>
    /** Return the path to the IPC server. */
    getPath(): string
    /** Stop the IPC server. */
    stop(): void
    /**
     * Send a message over the IPC server to all the connected clients
     *
     * @return The number of clients that the message was sent to. Note that the number of
     * messages actually received may be less, as some clients could disconnect before
     * receiving the message.
     */
    send(message: string): number
  }
  export interface IpcMessage {
    clientId: number
    kind: IpcMessageType
    message?: string
  }
  export const enum IpcMessageType {
    Connected = 0,
    Disconnected = 1,
    Message = 2
  }
}

export declare namespace logging {
  export function initNapiLog(jsLogFn: ((err: Error | null, arg0: LogLevel, arg1: string) => any)): void
  export const enum LogLevel {
    Trace = 0,
    Debug = 1,
    Info = 2,
    Warn = 3,
    Error = 4
  }
}

export declare namespace passkey_authenticator {
  export function register(): void
}

export declare namespace passwords {
  /**
   * Delete the stored password from the keychain.
   * Throws {@link Error} with message {@link PASSWORD_NOT_FOUND} if the password does not exist.
   */
  export function deletePassword(service: string, account: string): Promise<void>
  /**
   * Fetch the stored password from the keychain.
   * Throws {@link Error} with message {@link PASSWORD_NOT_FOUND} if the password does not exist.
   */
  export function getPassword(service: string, account: string): Promise<string>
  /** Checks if the os secure storage is available */
  export function isAvailable(): Promise<boolean>
  /** The error message returned when a password is not found during retrieval or deletion. */
  export const PASSWORD_NOT_FOUND: string
  /**
   * Save the password to the keychain. Adds an entry if none exists otherwise updates the
   * existing entry.
   */
  export function setPassword(service: string, account: string, password: string): Promise<void>
}

export declare namespace powermonitors {
  export function isLockMonitorAvailable(): Promise<boolean>
  export function onLock(callback: ((err: Error | null, ) => any)): Promise<void>
}

export declare namespace processisolations {
  export function disableCoredumps(): Promise<void>
  export function isCoreDumpingDisabled(): Promise<boolean>
  export function isolateProcess(): Promise<void>
}

export declare namespace sshagent {
  export class SshAgentState {

  }
  export function clearKeys(agentState: SshAgentState): void
  export function isRunning(agentState: SshAgentState): boolean
  export function lock(agentState: SshAgentState): void
  export interface PrivateKey {
    privateKey: string
    name: string
    cipherId: string
  }
  export function serve(callback: ((err: Error | null, arg: SshUiRequest) => Promise<boolean>)): Promise<SshAgentState>
  export function setKeys(agentState: SshAgentState, newKeys: Array<PrivateKey>): void
  export interface SshKey {
    privateKey: string
    publicKey: string
    keyFingerprint: string
  }
  export interface SshUiRequest {
    cipherId?: string
    isList: boolean
    processName: string
    isForwarding: boolean
    namespace?: string
  }
  export function stop(agentState: SshAgentState): void
}

export declare namespace windows_registry {
  export function createKey(key: string, subkey: string, value: string): Promise<void>
  export function deleteKey(key: string, subkey: string): Promise<void>
}
